name: CI

permissions:
  actions: read

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  c9s-bootc-e2e:
    strategy:
      matrix:
        runner:
          - ubuntu-24.04
          - ubuntu-24.04-arm

    runs-on: [ "${{ matrix.runner }}" ]

    steps:
      - name: Get a newer podman for heredoc support (from debian testing)
        run: |
          set -eux
          echo 'deb [trusted=yes] https://ftp.debian.org/debian/ testing main' | sudo tee /etc/apt/sources.list.d/testing.list
          sudo apt update
          sudo apt install -y crun/testing podman/testing skopeo/testing

      - uses: actions/checkout@v4

      - name: Install podman
        if: ( matrix.runner == 'ubuntu-24.04-arm' )
        run: |
          sudo apt update -y
          sudo apt install -y podman

      - name: build
        run: sudo podman build -t localhost/bootupd:latest -f Dockerfile .

      - name: bootupctl status in container
        run: |
          set -xeuo pipefail
          arch="$(uname --machine)"
          if [[ "${arch}" == "x86_64" ]]; then
            components_text='Available components: BIOS EFI'
            components_json='{"components":["BIOS","EFI"]}'
          else
            # Assume aarch64 for now
            components_text='Available components: EFI'
            components_json='{"components":["EFI"]}'
          fi
          output=$(sudo podman run --rm -ti localhost/bootupd:latest bootupctl status | tr -d '\r')
          [ "${components_text}" == "${output}" ]
          output=$(sudo podman run --rm -ti localhost/bootupd:latest bootupctl status --json)
          [ "${components_json}" == "${output}" ]

      - name: bootc install to disk
        run: |
          set -xeuo pipefail
          sudo truncate -s 10G myimage.raw
          sudo podman run --rm --privileged -v .:/target --pid=host --security-opt label=disable \
            -v /var/lib/containers:/var/lib/containers \
            -v /dev:/dev \
            localhost/bootupd:latest bootc install to-disk --skip-fetch-check \
            --disable-selinux --generic-image --via-loopback /target/myimage.raw
          # Verify we installed grub.cfg and shim on the disk
          sudo losetup -P -f myimage.raw
          device=$(losetup -a myimage.raw --output NAME -n)
          esp_part=$(sudo sfdisk -l -J "${device}" | jq -r '.partitiontable.partitions[] | select(.type == "C12A7328-F81F-11D2-BA4B-00A0C93EC93B").node')
          sudo mount "${esp_part}" /mnt/
          arch="$(uname --machine)"
          if [[ "${arch}" == "x86_64" ]]; then
            shim="shimx64.efi"
          else
            # Assume aarch64 for now
            shim="shimaa64.efi"
          fi
          sudo ls /mnt/EFI/centos/{grub.cfg,${shim}}
          sudo umount /mnt
          # check /boot/grub2/grub.cfg permission
          root_part=$(sudo sfdisk -l -J "${device}" | jq -r '.partitiontable.partitions[] | select(.name == "root").node')
          sudo mount "${root_part}" /mnt/
          sudo ls /mnt/boot/grub2/grub.cfg
          [ $(sudo stat -c "%a" /mnt/boot/grub2/grub.cfg) == "600" ]
          sudo umount /mnt
          sudo losetup -D "${device}"
          sudo rm -f myimage.raw

      - name: bootc install to filesystem
        run: |
          set -xeuo pipefail
          sudo podman run --rm -ti --privileged -v /:/target --pid=host --security-opt label=disable \
            -v /dev:/dev -v /var/lib/containers:/var/lib/containers \
            localhost/bootupd:latest bootc install to-filesystem --skip-fetch-check \
            --acknowledge-destructive \
            --disable-selinux --replace=alongside /target
          # Verify we injected static configs
          jq -re '.["static-configs"].version' /boot/bootupd-state.json
          [ $(sudo stat -c "%a" /boot/grub2/grub.cfg) == "600" ]

      - name: bootupctl generate-update-metadata
        run: |
          set -xeuo pipefail
          # This will be helpful when we extend /usr
          sudo podman run --rm -it --privileged localhost/bootupd:latest \
            bash -c '
              updates=/usr/lib/bootupd/updates
              rm -fv ${updates}/{BIOS,EFI}.json
              cp -r ${updates}/EFI /usr/lib/ostree-boot/efi
              # prepare /usr/lib/efi/<grub2|shim>/<ver>
              if [ ! -d "/usr/lib/efi" ]; then
                arch="$(uname --machine)"
                if [[ "${arch}" == "x86_64" ]]; then
                  surfix="x64"
                else
                  # Assume aarch64 for now
                  surfix="aa64"
                fi

                grub_ver=$(rpm -qa grub2-efi-${surfix} --queryformat '%{VERSION}-%{RELEASE}')
                mkdir -p /usr/lib/efi/grub2/${grub_ver}/EFI/centos
                mv ${updates}/EFI/centos/grub${surfix}.efi /usr/lib/efi/grub2/${grub_ver}/EFI/centos/

                shim_ver=$(rpm -qa shim-${surfix} --queryformat '%{VERSION}-%{RELEASE}')
                mkdir -p /usr/lib/efi/shim/${shim_ver}/EFI/
                mv ${updates}/EFI /usr/lib/efi/shim/${shim_ver}/
              else
                rm -rf ${updates}/EFI
              fi
              bootupctl backend generate-update-metadata -vvv
              cat ${updates}/EFI.json | jq
            '

      - name: Test install after extend-payload
        run: |
          set -xeuo pipefail
          sudo truncate -s 5G myimage-extend.raw
          sudo podman run --rm --privileged -v .:/target --pid=host --security-opt label=disable \
            -v /var/lib/containers:/var/lib/containers \
            -v /dev:/dev \
            localhost/bootupd:latest bash -c '
              # Create test firmware directory and files
              mkdir -p /usr/share/uboot/rpi/overlays
              echo "test uboot binary content" > /usr/share/uboot/rpi/u-boot.bin
              echo "i2c device tree overlay" > /usr/share/uboot/rpi/overlays/i2c.dtb
              
              # Create a fake RPM database for testing
              mkdir -p /usr/lib/sysimage/rpm
              echo "fake rpm database" > /usr/lib/sysimage/rpm/Packages
              
              # Create mock rpm script using a here-document for clarity
              cat << '"'EOT'"' > /usr/local/bin/rpm
              #!/bin/bash
              if [[ "$*" == *"-q"* ]] && [[ "$*" == *"-f"* ]]; then
                  echo "uboot-images-2023.04-2.fc42.noarch,1681234567"
                  exit 0
              fi
              exec /usr/bin/rpm.orig "$@"
              EOT
              
              # Backup original rpm and make our mock executable
              cp /usr/bin/rpm /usr/bin/rpm.orig
              chmod +x /usr/local/bin/rpm
              export PATH="/usr/local/bin:$PATH"
              
              # Run extend-payload-to-esp first
              bootupctl backend extend-payload-to-esp /usr/share/uboot/rpi
              
              # Verify firmware was extended correctly
              test -d /usr/lib/efi/firmware || { echo "firmware directory not created"; exit 1; }
              firmware_ver_dir=$(find /usr/lib/efi/firmware -name "*2023.04*" -type d | head -1)
              test -n "${firmware_ver_dir}" || { echo "firmware version directory not found"; exit 1; }
              test -f "${firmware_ver_dir}/EFI/u-boot.bin" || { echo "u-boot.bin not copied"; exit 1; }
              echo "âœ“ extend-payload completed successfully"
              # Now test install to disk with extended firmware
              bootc install to-disk --skip-fetch-check \
                --disable-selinux --generic-image --via-loopback /target/myimage-extend.raw
            '
            
          # Verify firmware files were installed to ESP
          sudo losetup -P -f myimage-extend.raw
          device=$(losetup -a myimage-extend.raw --output NAME -n)
          esp_part=$(sudo sfdisk -l -J "${device}" | jq -r '.partitiontable.partitions[] | select(.type == "C12A7328-F81F-11D2-BA4B-00A0C93EC93B").node')
          sudo mount "${esp_part}" /mnt/
          
          # Check that firmware files were copied to ESP during install
          if sudo test -f /mnt/u-boot.bin; then
            sudo grep -q "test uboot binary content" /mnt/u-boot.bin || { echo "u-boot.bin content incorrect on ESP"; exit 1; }
            echo "âœ“ Firmware files correctly installed to ESP"
          else
            echo "Note: u-boot.bin not found on ESP (firmware install integration may need work)"
          fi
          
          sudo umount /mnt
          sudo losetup -D "${device}"
          sudo rm -f myimage-extend.raw

      - name: Test update after extend-payload
        run: |
          set -xeuo pipefail
          sudo truncate -s 5G myimage-update.raw
          sudo podman run --rm --privileged -v .:/target --pid=host --security-opt label=disable \
            -v /var/lib/containers:/var/lib/containers \
            -v /dev:/dev \
            localhost/bootupd:latest bash -c '
              # Create initial test firmware directory and files
              mkdir -p /usr/share/uboot/rpi/overlays
              echo "initial uboot binary content v1.0" > /usr/share/uboot/rpi/u-boot.bin
              echo "initial i2c device tree overlay" > /usr/share/uboot/rpi/overlays/i2c.dtb
              
              # Create a fake RPM database for testing
              mkdir -p /usr/lib/sysimage/rpm
              echo "fake rpm database" > /usr/lib/sysimage/rpm/Packages
              
              # Create mock rpm script that returns initial package data
              cat << '"'EOT'"' > /usr/local/bin/rpm
              #!/bin/bash
              if [[ "$*" == *"-q"* ]] && [[ "$*" == *"-f"* ]]; then
                  echo "uboot-images-2023.04-1.fc42.noarch,1681234567"
                  exit 0
              fi
              exec /usr/bin/rpm.orig "$@"
              EOT
              
              # Backup original rpm and make our mock executable
              cp /usr/bin/rpm /usr/bin/rpm.orig
              chmod +x /usr/local/bin/rpm
              export PATH="/usr/local/bin:$PATH"
              
              # Run initial extend-payload-to-esp
              bootupctl backend extend-payload-to-esp /usr/share/uboot/rpi
              
              # Verify initial firmware was extended correctly
              test -d /usr/lib/efi/firmware || { echo "firmware directory not created"; exit 1; }
              firmware_ver_dir=$(find /usr/lib/efi/firmware -name "*2023.04-1*" -type d | head -1)
              test -n "${firmware_ver_dir}" || { echo "initial firmware version directory not found"; exit 1; }
              test -f "${firmware_ver_dir}/EFI/u-boot.bin" || { echo "initial u-boot.bin not copied"; exit 1; }
              grep -q "initial uboot binary content v1.0" "${firmware_ver_dir}/EFI/u-boot.bin"
              echo "âœ“ initial extend-payload completed successfully"
              
              # Install to disk with initial firmware
              bootc install to-disk --skip-fetch-check \
                --disable-selinux --generic-image --via-loopback /target/myimage-update.raw
              
              # Now simulate a firmware update by creating new firmware files
              echo "updated uboot binary content v2.0" > /usr/share/uboot/rpi/u-boot.bin
              echo "updated i2c device tree overlay" > /usr/share/uboot/rpi/overlays/i2c.dtb
              echo "new overlay for v2" > /usr/share/uboot/rpi/overlays/spi.dtb
              
              # Update mock rpm to return new version
              cat << '"'EOT'"' > /usr/local/bin/rpm
              #!/bin/bash
              if [[ "$*" == *"-q"* ]] && [[ "$*" == *"-f"* ]]; then
                  echo "uboot-images-2023.04-2.fc42.noarch,1681234999"
                  exit 0
              fi
              exec /usr/bin/rpm.orig "$@"
              EOT
              
              # Run updated extend-payload-to-esp
              bootupctl backend extend-payload-to-esp /usr/share/uboot/rpi
              
              # Verify updated firmware was extended correctly (only v2.0 should exist now)
              updated_firmware_ver_dir=$(find /usr/lib/efi/firmware -name "*2023.04-2*" -type d | head -1)
              test -n "${updated_firmware_ver_dir}" || { echo "updated firmware version directory not found"; exit 1; }
              test -f "${updated_firmware_ver_dir}/EFI/u-boot.bin" || { echo "updated u-boot.bin not copied"; exit 1; }
              grep -q "updated uboot binary content v2.0" "${updated_firmware_ver_dir}/EFI/u-boot.bin"
              test -f "${updated_firmware_ver_dir}/EFI/overlays/spi.dtb" || { echo "new spi.dtb not copied"; exit 1; }
              
              # Verify old version (2023.04-1) was removed
              old_firmware_ver_dir=$(find /usr/lib/efi/firmware -name "*2023.04-1*" -type d | head -1)
              test -z "${old_firmware_ver_dir}" || { echo "old firmware version should have been removed but still exists: ${old_firmware_ver_dir}"; exit 1; }
              
              echo "âœ“ updated extend-payload completed successfully (old version cleaned up)"
              
              # Run bootupctl update to apply the updated firmware to ESP
              bootupctl update
              echo "âœ“ bootupctl update completed successfully"
            '
            
          # Verify updated firmware files were applied to ESP
          sudo losetup -P -f myimage-update.raw
          device=$(losetup -a myimage-update.raw --output NAME -n)
          esp_part=$(sudo sfdisk -l -J "${device}" | jq -r '.partitiontable.partitions[] | select(.type == "C12A7328-F81F-11D2-BA4B-00A0C93EC93B").node')
          sudo mount "${esp_part}" /mnt/
          
          # Check that updated firmware files were applied to ESP during update
          if sudo test -f /mnt/u-boot.bin; then
            sudo grep -q "updated uboot binary content v2.0" /mnt/u-boot.bin || { echo "u-boot.bin was not updated on ESP"; exit 1; }
            echo "âœ“ Updated firmware files correctly applied to ESP"
          else
            echo "Warning: u-boot.bin not found on ESP after update"
            exit 1
          fi
          
          # Check that new overlay file was also copied
          if sudo test -f /mnt/overlays/spi.dtb; then
            sudo grep -q "new overlay for v2" /mnt/overlays/spi.dtb || { echo "spi.dtb content incorrect on ESP"; exit 1; }
            echo "âœ“ New overlay files correctly applied to ESP"
          else
            echo "Warning: new spi.dtb not found on ESP after update"
          fi
          
          # Verify checksums and state integrity
          echo "ðŸ” Validating firmware checksums and state integrity..."
          sudo podman run --rm --privileged -v .:/target --pid=host --security-opt label=disable \
            -v /var/lib/containers:/var/lib/containers \
            -v /dev:/dev \
            localhost/bootupd:latest bash -c '
              # Run bootupctl validate to check all checksums
              bootupctl validate || { echo "bootupctl validate failed - checksum mismatch detected"; exit 1; }
              echo "âœ“ All file checksums validated successfully"
              
              # Check that bootupd-state.json reflects the updated firmware
              if test -f /boot/bootupd-state.json; then
                # Verify firmware is tracked in state
                jq -e ".installed.EFI.firmware.uboot" /boot/bootupd-state.json >/dev/null || { echo "Updated firmware not found in bootupd-state.json"; exit 1; }
                echo "âœ“ Updated firmware properly tracked in bootupd-state.json"
              fi
            '
          
          sudo umount /mnt
          sudo losetup -D "${device}"
          sudo rm -f myimage-update.raw